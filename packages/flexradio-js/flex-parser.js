/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */

'use strict';

function peg$subclass(child, parent) {
	function ctor() { this.constructor = child; }
	ctor.prototype = parent.prototype;
	child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
	this.message = message;
	this.expected = expected;
	this.found = found;
	this.location = location;
	this.name = 'SyntaxError';

	if (typeof Error.captureStackTrace === 'function') {
		Error.captureStackTrace(this, peg$SyntaxError);
	}
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
	const DESCRIBE_EXPECTATION_FNS = {
		literal: function(expectation) {
			return '"' + literalEscape(expectation.text) + '"';
		},

		class: function(expectation) {
			let escapedParts = '';
			let i;

			for (i = 0; i < expectation.parts.length; i++) {
				escapedParts += expectation.parts[i] instanceof Array
					? classEscape(expectation.parts[i][0]) + '-' + classEscape(expectation.parts[i][1])
					: classEscape(expectation.parts[i]);
			}

			return '[' + (expectation.inverted ? '^' : '') + escapedParts + ']';
		},

		any: function(expectation) {
			return 'any character';
		},

		end: function(expectation) {
			return 'end of input';
		},

		other: function(expectation) {
			return expectation.description;
		}
	};

	function hex(ch) {
		return ch.charCodeAt(0).toString(16).toUpperCase();
	}

	function literalEscape(s) {
		return s
			.replace(/\\/g, '\\\\')
			.replace(/"/g, '\\"')
			.replace(/\0/g, '\\0')
			.replace(/\t/g, '\\t')
			.replace(/\n/g, '\\n')
			.replace(/\r/g, '\\r')
			.replace(/[\x00-\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
			.replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x' + hex(ch); });
	}

	function classEscape(s) {
		return s
			.replace(/\\/g, '\\\\')
			.replace(/\]/g, '\\]')
			.replace(/\^/g, '\\^')
			.replace(/-/g, '\\-')
			.replace(/\0/g, '\\0')
			.replace(/\t/g, '\\t')
			.replace(/\n/g, '\\n')
			.replace(/\r/g, '\\r')
			.replace(/[\x00-\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
			.replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x' + hex(ch); });
	}

	function describeExpectation(expectation) {
		return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
	}

	function describeExpected(expected) {
		const descriptions = new Array(expected.length);
		let i; let j;

		for (i = 0; i < expected.length; i++) {
			descriptions[i] = describeExpectation(expected[i]);
		}

		descriptions.sort();

		if (descriptions.length > 0) {
			for (i = 1, j = 1; i < descriptions.length; i++) {
				if (descriptions[i - 1] !== descriptions[i]) {
					descriptions[j] = descriptions[i];
					j++;
				}
			}
			descriptions.length = j;
		}

		switch (descriptions.length) {
			case 1:
				return descriptions[0];

			case 2:
				return descriptions[0] + ' or ' + descriptions[1];

			default:
				return descriptions.slice(0, -1).join(', ') +
          ', or ' +
          descriptions[descriptions.length - 1];
		}
	}

	function describeFound(found) {
		return found ? '"' + literalEscape(found) + '"' : 'end of input';
	}

	return 'Expected ' + describeExpected(expected) + ' but ' + describeFound(found) + ' found.';
};

function peg$parse(input, options) {
	options = options !== void 0 ? options : {};

	const peg$FAILED = {};

	const peg$startRuleFunctions = { Start: peg$parseStart };
	let peg$startRuleFunction = peg$parseStart;

	const peg$c0 = peg$otherExpectation('Message');
	const peg$c1 = 'M';
	const peg$c2 = peg$literalExpectation('M', false);
	const peg$c3 = '|';
	const peg$c4 = peg$literalExpectation('|', false);
	const peg$c5 = peg$anyExpectation();
	const peg$c6 = function(message_id, message) {
		return {
			type: 'message',
          			message_id: message_id,
			payload: message.join('')
		};
	};
	const peg$c7 = peg$otherExpectation('Status');
	const peg$c8 = 'S';
	const peg$c9 = peg$literalExpectation('S', false);
	const peg$c10 = function(client, response) {
		return {
			type: 'status',
          			client: client,
			topic: makeTopic(response),
			payload: makePayload(response)
		};
	};
	const peg$c11 = peg$otherExpectation('Response');
	const peg$c12 = 'R';
	const peg$c13 = peg$literalExpectation('R', false);
	const peg$c14 = function(sequence, code, response) {
		return {
			type: 'response',
          			sequence_number: sequence,
			response_code: code,
			topic: makeTopic(response),
			payload: makePayload(response)
      		};
	};
	const peg$c15 = peg$otherExpectation('Handle');
	const peg$c16 = 'H';
	const peg$c17 = peg$literalExpectation('H', false);
	const peg$c18 = function(client) {
		return {
			type: 'handle',
          			payload: client
		};
	};
	const peg$c19 = peg$otherExpectation('Version');
	const peg$c20 = 'V';
	const peg$c21 = peg$literalExpectation('V', false);
	const peg$c22 = function(version) {
		return {
			type: 'version',
          			payload: version
		};
	};
	const peg$c23 = peg$otherExpectation('Payload');
	const peg$c24 = peg$otherExpectation('version_info');
	const peg$c25 = 'SmartSDR';
	const peg$c26 = peg$literalExpectation('SmartSDR', false);
	const peg$c27 = function(m) { return ['version', ...m]; };
	const peg$c28 = peg$otherExpectation('Info');
	const peg$c29 = 'model=';
	const peg$c30 = peg$literalExpectation('model=', false);
	const peg$c31 = function(m) { return ['info', ...m]; };
	const peg$c32 = peg$otherExpectation('GPS');
	const peg$c33 = 'gps';
	const peg$c34 = peg$literalExpectation('gps', false);
	const peg$c35 = function(m) { return ['gps', ...m]; };
	const peg$c36 = peg$otherExpectation('Meter');
	const peg$c37 = 'meter';
	const peg$c38 = peg$literalExpectation('meter', false);
	const peg$c39 = function(m) { return ['meter', ...m]; };
	const peg$c40 = peg$otherExpectation('Profile');
	const peg$c41 = 'profile';
	const peg$c42 = peg$literalExpectation('profile', false);
	const peg$c43 = function(t, m) { return ['profile', t, ...m]; };
	const peg$c44 = peg$otherExpectation('Profile_List');
	const peg$c45 = 'list=';
	const peg$c46 = peg$literalExpectation('list=', false);
	const peg$c47 = function(m) { return [['list', m]]; };
	const peg$c48 = peg$otherExpectation('Space_KV_List');
	const peg$c49 = function(head, tail) { return [head].concat(tail); };
	const peg$c50 = peg$otherExpectation('Space_KV_List_Tail');
	const peg$c51 = function(m) { return m; };
	const peg$c52 = peg$otherExpectation('Space_KV_Member');
	const peg$c53 = '=';
	const peg$c54 = peg$literalExpectation('=', false);
	const peg$c55 = function(key, eq, value) { return eq ? [key, value] : key; };
	const peg$c56 = peg$otherExpectation('Space_KV_Token');
	const peg$c57 = /^[^ =\t]/;
	const peg$c58 = peg$classExpectation([' ', '=', '\t'], true, false);
	const peg$c59 = function(chars) { return chars.join(''); };
	const peg$c60 = peg$otherExpectation('Comma_KV_List');
	const peg$c61 = peg$otherExpectation('Comma_KV_List_Tail');
	const peg$c62 = peg$otherExpectation('Comma_KV_Member');
	const peg$c63 = peg$otherExpectation('Comma_KV_Token');
	const peg$c64 = /^[^,=]/;
	const peg$c65 = peg$classExpectation([',', '='], true, false);
	const peg$c66 = peg$otherExpectation('Hash_KV_List');
	const peg$c67 = peg$otherExpectation('Hash_KV_List_Tail');
	const peg$c68 = peg$otherExpectation('Hash_KV_Member');
	const peg$c69 = function(key, eq, value) { return eq ? [...key, value] : key; };
	const peg$c70 = peg$otherExpectation('Hash_KV_Key');
	const peg$c71 = function(key) { return [key]; };
	const peg$c72 = peg$otherExpectation('Hash_KV_Complex_Key');
	const peg$c73 = '.';
	const peg$c74 = peg$literalExpectation('.', false);
	const peg$c75 = function(n, key) { return [n, key]; };
	const peg$c76 = peg$otherExpectation('Hash_KV_Toksn');
	const peg$c77 = /^[^#=\t]/;
	const peg$c78 = peg$classExpectation(['#', '=', '\t'], true, false);
	const peg$c79 = '#';
	const peg$c80 = peg$literalExpectation('#', false);
	const peg$c81 = function(t) { return t; };
	const peg$c82 = /^[^,]/;
	const peg$c83 = peg$classExpectation([','], true, false);
	const peg$c84 = ',';
	const peg$c85 = peg$literalExpectation(',', false);
	const peg$c86 = peg$otherExpectation('Caret_List');
	const peg$c87 = peg$otherExpectation('Caret_List_Tail');
	const peg$c88 = peg$otherExpectation('Caret_Token');
	const peg$c89 = /^[^\^]/;
	const peg$c90 = peg$classExpectation(['^'], true, false);
	const peg$c91 = '^';
	const peg$c92 = peg$literalExpectation('^', false);
	const peg$c93 = peg$otherExpectation('Version_Number');
	const peg$c94 = function(major, minor, patch, build) {
		return {
          	version: major + '.' + minor + '.' + patch + '.' + build,
          	major: major,
             	minor: minor,
             	patch: patch,
             	build: build
      		};
      	};
	const peg$c95 = peg$otherExpectation('String');
	const peg$c96 = peg$otherExpectation('String_unquoted');
	const peg$c97 = /^[^ ,#\t\n\r\f]/;
	const peg$c98 = peg$classExpectation([' ', ',', '#', '\t', '\n', '\r', '\f'], true, false);
	const peg$c99 = peg$otherExpectation('String_quoted');
	const peg$c100 = '"';
	const peg$c101 = peg$literalExpectation('"', false);
	const peg$c102 = /^[^"]/;
	const peg$c103 = peg$classExpectation(['"'], true, false);
	const peg$c104 = peg$otherExpectation('Hex_String');
	const peg$c105 = /^[0-9a-fA-F]/;
	const peg$c106 = peg$classExpectation([['0', '9'], ['a', 'f'], ['A', 'F']], false, false);
	const peg$c107 = function() { return text(); };
	const peg$c108 = peg$otherExpectation('Integer');
	const peg$c109 = /^[0-9]/;
	const peg$c110 = peg$classExpectation([['0', '9']], false, false);
	const peg$c111 = function() { return parseInt(text(), 10); };
	const peg$c112 = peg$otherExpectation('whitespace');
	const peg$c113 = /^[ \t\n\r]/;
	const peg$c114 = peg$classExpectation([' ', '\t', '\n', '\r'], false, false);

	let peg$currPos = 0;
	let peg$savedPos = 0;
	const peg$posDetailsCache = [{ line: 1, column: 1 }];
	let peg$maxFailPos = 0;
	let peg$maxFailExpected = [];
	let peg$silentFails = 0;

	let peg$result;

	if ('startRule' in options) {
		if (!(options.startRule in peg$startRuleFunctions)) {
			throw new Error("Can't start parsing from rule \"" + options.startRule + '".');
		}

		peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	}

	function text() {
		return input.substring(peg$savedPos, peg$currPos);
	}

	function location() {
		return peg$computeLocation(peg$savedPos, peg$currPos);
	}

	function expected(description, location) {
		location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);

		throw peg$buildStructuredError(
			[peg$otherExpectation(description)],
			input.substring(peg$savedPos, peg$currPos),
			location
		);
	}

	function error(message, location) {
		location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);

		throw peg$buildSimpleError(message, location);
	}

	function peg$literalExpectation(text, ignoreCase) {
		return { type: 'literal', text: text, ignoreCase: ignoreCase };
	}

	function peg$classExpectation(parts, inverted, ignoreCase) {
		return { type: 'class', parts: parts, inverted: inverted, ignoreCase: ignoreCase };
	}

	function peg$anyExpectation() {
		return { type: 'any' };
	}

	function peg$endExpectation() {
		return { type: 'end' };
	}

	function peg$otherExpectation(description) {
		return { type: 'other', description: description };
	}

	function peg$computePosDetails(pos) {
		let details = peg$posDetailsCache[pos]; let p;

		if (details) {
			return details;
		} else {
			p = pos - 1;
			while (!peg$posDetailsCache[p]) {
				p--;
			}

			details = peg$posDetailsCache[p];
			details = {
				line: details.line,
				column: details.column
			};

			while (p < pos) {
				if (input.charCodeAt(p) === 10) {
					details.line++;
					details.column = 1;
				} else {
					details.column++;
				}

				p++;
			}

			peg$posDetailsCache[pos] = details;
			return details;
		}
	}

	function peg$computeLocation(startPos, endPos) {
		const startPosDetails = peg$computePosDetails(startPos);
		const endPosDetails = peg$computePosDetails(endPos);

		return {
			start: {
				offset: startPos,
				line: startPosDetails.line,
				column: startPosDetails.column
			},
			end: {
				offset: endPos,
				line: endPosDetails.line,
				column: endPosDetails.column
			}
		};
	}

	function peg$fail(expected) {
		if (peg$currPos < peg$maxFailPos) { return; }

		if (peg$currPos > peg$maxFailPos) {
			peg$maxFailPos = peg$currPos;
			peg$maxFailExpected = [];
		}

		peg$maxFailExpected.push(expected);
	}

	function peg$buildSimpleError(message, location) {
		return new peg$SyntaxError(message, null, null, location);
	}

	function peg$buildStructuredError(expected, found, location) {
		return new peg$SyntaxError(
			peg$SyntaxError.buildMessage(expected, found),
			expected,
			found,
			location
		);
	}

	function peg$parseStart() {
		let s0;

		s0 = peg$parseMessage();
		if (s0 === peg$FAILED) {
			s0 = peg$parseStatus();
			if (s0 === peg$FAILED) {
				s0 = peg$parseResponse();
				if (s0 === peg$FAILED) {
					s0 = peg$parseHandle();
					if (s0 === peg$FAILED) {
						s0 = peg$parseVersion();
					}
				}
			}
		}

		return s0;
	}

	function peg$parseMessage() {
		let s0, s1, s2, s3, s4, s5;

		peg$silentFails++;
		s0 = peg$currPos;
		if (input.charCodeAt(peg$currPos) === 77) {
			s1 = peg$c1;
			peg$currPos++;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c2); }
		}
		if (s1 !== peg$FAILED) {
			s2 = peg$parseInteger();
			if (s2 !== peg$FAILED) {
				if (input.charCodeAt(peg$currPos) === 124) {
					s3 = peg$c3;
					peg$currPos++;
				} else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c4); }
				}
				if (s3 !== peg$FAILED) {
					s4 = [];
					if (input.length > peg$currPos) {
						s5 = input.charAt(peg$currPos);
						peg$currPos++;
					} else {
						s5 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$c5); }
					}
					while (s5 !== peg$FAILED) {
						s4.push(s5);
						if (input.length > peg$currPos) {
							s5 = input.charAt(peg$currPos);
							peg$currPos++;
						} else {
							s5 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c5); }
						}
					}
					if (s4 !== peg$FAILED) {
						peg$savedPos = s0;
						s1 = peg$c6(s2, s4);
						s0 = s1;
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c0); }
		}

		return s0;
	}

	function peg$parseStatus() {
		let s0, s1, s2, s3, s4;

		peg$silentFails++;
		s0 = peg$currPos;
		if (input.charCodeAt(peg$currPos) === 83) {
			s1 = peg$c8;
			peg$currPos++;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c9); }
		}
		if (s1 !== peg$FAILED) {
			s2 = peg$parseHex_String();
			if (s2 !== peg$FAILED) {
				if (input.charCodeAt(peg$currPos) === 124) {
					s3 = peg$c3;
					peg$currPos++;
				} else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c4); }
				}
				if (s3 !== peg$FAILED) {
					s4 = peg$parsePayload();
					if (s4 !== peg$FAILED) {
						peg$savedPos = s0;
						s1 = peg$c10(s2, s4);
						s0 = s1;
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c7); }
		}

		return s0;
	}

	function peg$parseResponse() {
		let s0, s1, s2, s3, s4, s5, s6;

		peg$silentFails++;
		s0 = peg$currPos;
		if (input.charCodeAt(peg$currPos) === 82) {
			s1 = peg$c12;
			peg$currPos++;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c13); }
		}
		if (s1 !== peg$FAILED) {
			s2 = peg$parseInteger();
			if (s2 !== peg$FAILED) {
				if (input.charCodeAt(peg$currPos) === 124) {
					s3 = peg$c3;
					peg$currPos++;
				} else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c4); }
				}
				if (s3 !== peg$FAILED) {
					s4 = peg$parseHex_String();
					if (s4 !== peg$FAILED) {
						if (input.charCodeAt(peg$currPos) === 124) {
							s5 = peg$c3;
							peg$currPos++;
						} else {
							s5 = peg$FAILED;
							if (peg$silentFails === 0) { peg$fail(peg$c4); }
						}
						if (s5 !== peg$FAILED) {
							s6 = peg$parsePayload();
							if (s6 === peg$FAILED) {
								s6 = null;
							}
							if (s6 !== peg$FAILED) {
								peg$savedPos = s0;
								s1 = peg$c14(s2, s4, s6);
								s0 = s1;
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c11); }
		}

		return s0;
	}

	function peg$parseHandle() {
		let s0, s1, s2;

		peg$silentFails++;
		s0 = peg$currPos;
		if (input.charCodeAt(peg$currPos) === 72) {
			s1 = peg$c16;
			peg$currPos++;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c17); }
		}
		if (s1 !== peg$FAILED) {
			s2 = peg$parseHex_String();
			if (s2 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c18(s2);
				s0 = s1;
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c15); }
		}

		return s0;
	}

	function peg$parseVersion() {
		let s0, s1, s2;

		peg$silentFails++;
		s0 = peg$currPos;
		if (input.charCodeAt(peg$currPos) === 86) {
			s1 = peg$c20;
			peg$currPos++;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c21); }
		}
		if (s1 !== peg$FAILED) {
			s2 = peg$parseVersion_Number();
			if (s2 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c22(s2);
				s0 = s1;
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c19); }
		}

		return s0;
	}

	function peg$parsePayload() {
		let s0, s1;

		peg$silentFails++;
		s0 = peg$parseProfile();
		if (s0 === peg$FAILED) {
			s0 = peg$parseMeter();
			if (s0 === peg$FAILED) {
				s0 = peg$parseGPS();
				if (s0 === peg$FAILED) {
					s0 = peg$parseInfo();
					if (s0 === peg$FAILED) {
						s0 = peg$parseVersion_Info();
						if (s0 === peg$FAILED) {
							s0 = peg$parseSpace_KV_List();
						}
					}
				}
			}
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c23); }
		}

		return s0;
	}

	function peg$parseVersion_Info() {
		let s0, s1, s2;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$currPos;
		peg$silentFails++;
		if (input.substr(peg$currPos, 8) === peg$c25) {
			s2 = peg$c25;
			peg$currPos += 8;
		} else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c26); }
		}
		peg$silentFails--;
		if (s2 !== peg$FAILED) {
			peg$currPos = s1;
			s1 = void 0;
		} else {
			s1 = peg$FAILED;
		}
		if (s1 !== peg$FAILED) {
			s2 = peg$parseHash_KV_List();
			if (s2 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c27(s2);
				s0 = s1;
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c24); }
		}

		return s0;
	}

	function peg$parseInfo() {
		let s0, s1, s2;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$currPos;
		peg$silentFails++;
		if (input.substr(peg$currPos, 6) === peg$c29) {
			s2 = peg$c29;
			peg$currPos += 6;
		} else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c30); }
		}
		peg$silentFails--;
		if (s2 !== peg$FAILED) {
			peg$currPos = s1;
			s1 = void 0;
		} else {
			s1 = peg$FAILED;
		}
		if (s1 !== peg$FAILED) {
			s2 = peg$parseComma_KV_List();
			if (s2 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c31(s2);
				s0 = s1;
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c28); }
		}

		return s0;
	}

	function peg$parseGPS() {
		let s0, s1, s2, s3;

		peg$silentFails++;
		s0 = peg$currPos;
		if (input.substr(peg$currPos, 3) === peg$c33) {
			s1 = peg$c33;
			peg$currPos += 3;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c34); }
		}
		if (s1 !== peg$FAILED) {
			s2 = peg$parse_();
			if (s2 !== peg$FAILED) {
				s3 = peg$parseHash_KV_List();
				if (s3 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c35(s3);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c32); }
		}

		return s0;
	}

	function peg$parseMeter() {
		let s0, s1, s2, s3;

		peg$silentFails++;
		s0 = peg$currPos;
		if (input.substr(peg$currPos, 5) === peg$c37) {
			s1 = peg$c37;
			peg$currPos += 5;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c38); }
		}
		if (s1 !== peg$FAILED) {
			s2 = peg$parse_();
			if (s2 !== peg$FAILED) {
				s3 = peg$parseHash_KV_List();
				if (s3 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c39(s3);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c36); }
		}

		return s0;
	}

	function peg$parseProfile() {
		let s0, s1, s2, s3, s4, s5;

		peg$silentFails++;
		s0 = peg$currPos;
		if (input.substr(peg$currPos, 7) === peg$c41) {
			s1 = peg$c41;
			peg$currPos += 7;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c42); }
		}
		if (s1 !== peg$FAILED) {
			s2 = peg$parse_();
			if (s2 !== peg$FAILED) {
				s3 = peg$parseString();
				if (s3 !== peg$FAILED) {
					s4 = peg$parse_();
					if (s4 !== peg$FAILED) {
						s5 = peg$parseProfile_List();
						if (s5 === peg$FAILED) {
							s5 = peg$parseSpace_KV_List();
						}
						if (s5 !== peg$FAILED) {
							peg$savedPos = s0;
							s1 = peg$c43(s3, s5);
							s0 = s1;
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c40); }
		}

		return s0;
	}

	function peg$parseProfile_List() {
		let s0, s1, s2;

		peg$silentFails++;
		s0 = peg$currPos;
		if (input.substr(peg$currPos, 5) === peg$c45) {
			s1 = peg$c45;
			peg$currPos += 5;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c46); }
		}
		if (s1 !== peg$FAILED) {
			s2 = peg$parseCaret_List();
			if (s2 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c47(s2);
				s0 = s1;
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c44); }
		}

		return s0;
	}

	function peg$parseSpace_KV_List() {
		let s0, s1, s2, s3;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$parseSpace_KV_Member();
		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$parseSpace_KV_List_Tail();
			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$parseSpace_KV_List_Tail();
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parse_();
				if (s3 === peg$FAILED) {
					s3 = null;
				}
				if (s3 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c49(s1, s2);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c48); }
		}

		return s0;
	}

	function peg$parseSpace_KV_List_Tail() {
		let s0, s1, s2;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$parse_();
		if (s1 !== peg$FAILED) {
			s2 = peg$parseSpace_KV_Member();
			if (s2 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c51(s2);
				s0 = s1;
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c50); }
		}

		return s0;
	}

	function peg$parseSpace_KV_Member() {
		let s0, s1, s2, s3;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$parseSpace_KV_Token();
		if (s1 !== peg$FAILED) {
			if (input.charCodeAt(peg$currPos) === 61) {
				s2 = peg$c53;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c54); }
			}
			if (s2 === peg$FAILED) {
				s2 = null;
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parseSpace_KV_Token();
				if (s3 === peg$FAILED) {
					s3 = null;
				}
				if (s3 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c55(s1, s2, s3);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c52); }
		}

		return s0;
	}

	function peg$parseSpace_KV_Token() {
		let s0, s1, s2;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = [];
		if (peg$c57.test(input.charAt(peg$currPos))) {
			s2 = input.charAt(peg$currPos);
			peg$currPos++;
		} else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c58); }
		}
		if (s2 !== peg$FAILED) {
			while (s2 !== peg$FAILED) {
				s1.push(s2);
				if (peg$c57.test(input.charAt(peg$currPos))) {
					s2 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s2 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c58); }
				}
			}
		} else {
			s1 = peg$FAILED;
		}
		if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c59(s1);
		}
		s0 = s1;
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c56); }
		}

		return s0;
	}

	function peg$parseComma_KV_List() {
		let s0, s1, s2, s3;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$parseComma_KV_Member();
		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$parseComma_KV_List_Tail();
			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$parseComma_KV_List_Tail();
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parseComma();
				if (s3 === peg$FAILED) {
					s3 = null;
				}
				if (s3 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c49(s1, s2);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c60); }
		}

		return s0;
	}

	function peg$parseComma_KV_List_Tail() {
		let s0, s1, s2;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$parseComma();
		if (s1 !== peg$FAILED) {
			s2 = peg$parseComma_KV_Member();
			if (s2 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c51(s2);
				s0 = s1;
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c61); }
		}

		return s0;
	}

	function peg$parseComma_KV_Member() {
		let s0, s1, s2, s3;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$parseComma_KV_Token();
		if (s1 !== peg$FAILED) {
			if (input.charCodeAt(peg$currPos) === 61) {
				s2 = peg$c53;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c54); }
			}
			if (s2 === peg$FAILED) {
				s2 = null;
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parseComma_KV_Token();
				if (s3 === peg$FAILED) {
					s3 = null;
				}
				if (s3 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c55(s1, s2, s3);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c62); }
		}

		return s0;
	}

	function peg$parseComma_KV_Token() {
		let s0, s1;

		peg$silentFails++;
		s0 = peg$parseString_quoted();
		if (s0 === peg$FAILED) {
			s0 = peg$parseComma_KV_Token_unquoted();
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c63); }
		}

		return s0;
	}

	function peg$parseComma_KV_Token_unquoted() {
		let s0, s1, s2;

		s0 = peg$currPos;
		s1 = [];
		if (peg$c64.test(input.charAt(peg$currPos))) {
			s2 = input.charAt(peg$currPos);
			peg$currPos++;
		} else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c65); }
		}
		if (s2 !== peg$FAILED) {
			while (s2 !== peg$FAILED) {
				s1.push(s2);
				if (peg$c64.test(input.charAt(peg$currPos))) {
					s2 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s2 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c65); }
				}
			}
		} else {
			s1 = peg$FAILED;
		}
		if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c59(s1);
		}
		s0 = s1;

		return s0;
	}

	function peg$parseHash_KV_List() {
		let s0, s1, s2, s3;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$parseHash_KV_Member();
		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$parseHash_KV_List_Tail();
			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$parseHash_KV_List_Tail();
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parseHash();
				if (s3 === peg$FAILED) {
					s3 = null;
				}
				if (s3 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c49(s1, s2);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c66); }
		}

		return s0;
	}

	function peg$parseHash_KV_List_Tail() {
		let s0, s1, s2;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$parseHash();
		if (s1 !== peg$FAILED) {
			s2 = peg$parseHash_KV_Member();
			if (s2 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c51(s2);
				s0 = s1;
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c67); }
		}

		return s0;
	}

	function peg$parseHash_KV_Member() {
		let s0, s1, s2, s3;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$parseHash_KV_Key();
		if (s1 !== peg$FAILED) {
			if (input.charCodeAt(peg$currPos) === 61) {
				s2 = peg$c53;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c54); }
			}
			if (s2 === peg$FAILED) {
				s2 = null;
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parseHash_KV_Token();
				if (s3 === peg$FAILED) {
					s3 = null;
				}
				if (s3 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c69(s1, s2, s3);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c68); }
		}

		return s0;
	}

	function peg$parseHash_KV_Key() {
		let s0, s1;

		peg$silentFails++;
		s0 = peg$parseHash_KV_Complex_Key();
		if (s0 === peg$FAILED) {
			s0 = peg$currPos;
			s1 = peg$parseHash_KV_Token();
			if (s1 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c71(s1);
			}
			s0 = s1;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c70); }
		}

		return s0;
	}

	function peg$parseHash_KV_Complex_Key() {
		let s0, s1, s2, s3;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$parseInteger();
		if (s1 !== peg$FAILED) {
			if (input.charCodeAt(peg$currPos) === 46) {
				s2 = peg$c73;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c74); }
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parseHash_KV_Token();
				if (s3 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c75(s1, s3);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c72); }
		}

		return s0;
	}

	function peg$parseHash_KV_Token() {
		let s0, s1, s2;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = [];
		if (peg$c77.test(input.charAt(peg$currPos))) {
			s2 = input.charAt(peg$currPos);
			peg$currPos++;
		} else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c78); }
		}
		if (s2 !== peg$FAILED) {
			while (s2 !== peg$FAILED) {
				s1.push(s2);
				if (peg$c77.test(input.charAt(peg$currPos))) {
					s2 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s2 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c78); }
				}
			}
		} else {
			s1 = peg$FAILED;
		}
		if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c59(s1);
		}
		s0 = s1;
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c76); }
		}

		return s0;
	}

	function peg$parseHash() {
		let s0;

		if (input.charCodeAt(peg$currPos) === 35) {
			s0 = peg$c79;
			peg$currPos++;
		} else {
			s0 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c80); }
		}

		return s0;
	}

	function peg$parseComma_List() {
		let s0, s1, s2, s3;

		s0 = peg$currPos;
		s1 = peg$parseComma_Token();
		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$parseComma_List_Tail();
			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$parseComma_List_Tail();
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parseComma();
				if (s3 === peg$FAILED) {
					s3 = null;
				}
				if (s3 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c49(s1, s2);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	function peg$parseComma_List_Tail() {
		let s0, s1, s2;

		s0 = peg$currPos;
		s1 = peg$parseComma();
		if (s1 !== peg$FAILED) {
			s2 = peg$parseComma_Token();
			if (s2 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c81(s2);
				s0 = s1;
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}

		return s0;
	}

	function peg$parseComma_Token() {
		let s0, s1, s2;

		s0 = peg$currPos;
		s1 = [];
		if (peg$c82.test(input.charAt(peg$currPos))) {
			s2 = input.charAt(peg$currPos);
			peg$currPos++;
		} else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c83); }
		}
		if (s2 !== peg$FAILED) {
			while (s2 !== peg$FAILED) {
				s1.push(s2);
				if (peg$c82.test(input.charAt(peg$currPos))) {
					s2 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s2 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c83); }
				}
			}
		} else {
			s1 = peg$FAILED;
		}
		if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c59(s1);
		}
		s0 = s1;

		return s0;
	}

	function peg$parseComma() {
		let s0;

		if (input.charCodeAt(peg$currPos) === 44) {
			s0 = peg$c84;
			peg$currPos++;
		} else {
			s0 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c85); }
		}

		return s0;
	}

	function peg$parseCaret_List() {
		let s0, s1, s2, s3;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$parseCaret_Token();
		if (s1 !== peg$FAILED) {
			s2 = [];
			s3 = peg$parseCaret_List_Tail();
			while (s3 !== peg$FAILED) {
				s2.push(s3);
				s3 = peg$parseCaret_List_Tail();
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parseCaret();
				if (s3 === peg$FAILED) {
					s3 = null;
				}
				if (s3 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c49(s1, s2);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c86); }
		}

		return s0;
	}

	function peg$parseCaret_List_Tail() {
		let s0, s1, s2;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$parseCaret();
		if (s1 !== peg$FAILED) {
			s2 = peg$parseCaret_Token();
			if (s2 !== peg$FAILED) {
				peg$savedPos = s0;
				s1 = peg$c51(s2);
				s0 = s1;
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c87); }
		}

		return s0;
	}

	function peg$parseCaret_Token() {
		let s0, s1, s2;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = [];
		if (peg$c89.test(input.charAt(peg$currPos))) {
			s2 = input.charAt(peg$currPos);
			peg$currPos++;
		} else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c90); }
		}
		if (s2 !== peg$FAILED) {
			while (s2 !== peg$FAILED) {
				s1.push(s2);
				if (peg$c89.test(input.charAt(peg$currPos))) {
					s2 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s2 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c90); }
				}
			}
		} else {
			s1 = peg$FAILED;
		}
		if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c59(s1);
		}
		s0 = s1;
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c88); }
		}

		return s0;
	}

	function peg$parseCaret() {
		let s0;

		if (input.charCodeAt(peg$currPos) === 94) {
			s0 = peg$c91;
			peg$currPos++;
		} else {
			s0 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c92); }
		}

		return s0;
	}

	function peg$parseVersion_Number() {
		let s0, s1, s2, s3, s4, s5, s6, s7;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = peg$parseInteger();
		if (s1 !== peg$FAILED) {
			if (input.charCodeAt(peg$currPos) === 46) {
				s2 = peg$c73;
				peg$currPos++;
			} else {
				s2 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c74); }
			}
			if (s2 !== peg$FAILED) {
				s3 = peg$parseInteger();
				if (s3 !== peg$FAILED) {
					if (input.charCodeAt(peg$currPos) === 46) {
						s4 = peg$c73;
						peg$currPos++;
					} else {
						s4 = peg$FAILED;
						if (peg$silentFails === 0) { peg$fail(peg$c74); }
					}
					if (s4 !== peg$FAILED) {
						s5 = peg$parseInteger();
						if (s5 !== peg$FAILED) {
							if (input.charCodeAt(peg$currPos) === 46) {
								s6 = peg$c73;
								peg$currPos++;
							} else {
								s6 = peg$FAILED;
								if (peg$silentFails === 0) { peg$fail(peg$c74); }
							}
							if (s6 !== peg$FAILED) {
								s7 = peg$parseInteger();
								if (s7 !== peg$FAILED) {
									peg$savedPos = s0;
									s1 = peg$c94(s1, s3, s5, s7);
									s0 = s1;
								} else {
									peg$currPos = s0;
									s0 = peg$FAILED;
								}
							} else {
								peg$currPos = s0;
								s0 = peg$FAILED;
							}
						} else {
							peg$currPos = s0;
							s0 = peg$FAILED;
						}
					} else {
						peg$currPos = s0;
						s0 = peg$FAILED;
					}
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c93); }
		}

		return s0;
	}

	function peg$parseString() {
		let s0, s1;

		peg$silentFails++;
		s0 = peg$parseString_quoted();
		if (s0 === peg$FAILED) {
			s0 = peg$parseString_unquoted();
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c95); }
		}

		return s0;
	}

	function peg$parseString_unquoted() {
		let s0, s1, s2;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = [];
		if (peg$c97.test(input.charAt(peg$currPos))) {
			s2 = input.charAt(peg$currPos);
			peg$currPos++;
		} else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c98); }
		}
		if (s2 !== peg$FAILED) {
			while (s2 !== peg$FAILED) {
				s1.push(s2);
				if (peg$c97.test(input.charAt(peg$currPos))) {
					s2 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s2 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c98); }
				}
			}
		} else {
			s1 = peg$FAILED;
		}
		if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c59(s1);
		}
		s0 = s1;
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c96); }
		}

		return s0;
	}

	function peg$parseString_quoted() {
		let s0, s1, s2, s3;

		peg$silentFails++;
		s0 = peg$currPos;
		if (input.charCodeAt(peg$currPos) === 34) {
			s1 = peg$c100;
			peg$currPos++;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c101); }
		}
		if (s1 !== peg$FAILED) {
			s2 = [];
			if (peg$c102.test(input.charAt(peg$currPos))) {
				s3 = input.charAt(peg$currPos);
				peg$currPos++;
			} else {
				s3 = peg$FAILED;
				if (peg$silentFails === 0) { peg$fail(peg$c103); }
			}
			while (s3 !== peg$FAILED) {
				s2.push(s3);
				if (peg$c102.test(input.charAt(peg$currPos))) {
					s3 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c103); }
				}
			}
			if (s2 !== peg$FAILED) {
				if (input.charCodeAt(peg$currPos) === 34) {
					s3 = peg$c100;
					peg$currPos++;
				} else {
					s3 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c101); }
				}
				if (s3 !== peg$FAILED) {
					peg$savedPos = s0;
					s1 = peg$c59(s2);
					s0 = s1;
				} else {
					peg$currPos = s0;
					s0 = peg$FAILED;
				}
			} else {
				peg$currPos = s0;
				s0 = peg$FAILED;
			}
		} else {
			peg$currPos = s0;
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c99); }
		}

		return s0;
	}

	function peg$parseHex_String() {
		let s0, s1, s2;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = [];
		if (peg$c105.test(input.charAt(peg$currPos))) {
			s2 = input.charAt(peg$currPos);
			peg$currPos++;
		} else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c106); }
		}
		if (s2 !== peg$FAILED) {
			while (s2 !== peg$FAILED) {
				s1.push(s2);
				if (peg$c105.test(input.charAt(peg$currPos))) {
					s2 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s2 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c106); }
				}
			}
		} else {
			s1 = peg$FAILED;
		}
		if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c107();
		}
		s0 = s1;
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c104); }
		}

		return s0;
	}

	function peg$parseInteger() {
		let s0, s1, s2;

		peg$silentFails++;
		s0 = peg$currPos;
		s1 = [];
		if (peg$c109.test(input.charAt(peg$currPos))) {
			s2 = input.charAt(peg$currPos);
			peg$currPos++;
		} else {
			s2 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c110); }
		}
		if (s2 !== peg$FAILED) {
			while (s2 !== peg$FAILED) {
				s1.push(s2);
				if (peg$c109.test(input.charAt(peg$currPos))) {
					s2 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s2 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c110); }
				}
			}
		} else {
			s1 = peg$FAILED;
		}
		if (s1 !== peg$FAILED) {
			peg$savedPos = s0;
			s1 = peg$c111();
		}
		s0 = s1;
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c108); }
		}

		return s0;
	}

	function peg$parse_() {
		let s0, s1;

		peg$silentFails++;
		s0 = [];
		if (peg$c113.test(input.charAt(peg$currPos))) {
			s1 = input.charAt(peg$currPos);
			peg$currPos++;
		} else {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c114); }
		}
		if (s1 !== peg$FAILED) {
			while (s1 !== peg$FAILED) {
				s0.push(s1);
				if (peg$c113.test(input.charAt(peg$currPos))) {
					s1 = input.charAt(peg$currPos);
					peg$currPos++;
				} else {
					s1 = peg$FAILED;
					if (peg$silentFails === 0) { peg$fail(peg$c114); }
				}
			}
		} else {
			s0 = peg$FAILED;
		}
		peg$silentFails--;
		if (s0 === peg$FAILED) {
			s1 = peg$FAILED;
			if (peg$silentFails === 0) { peg$fail(peg$c112); }
		}

		return s0;
	}

  	function makeTopic(msg) {
		if (!msg || msg.length <= 1) {
          	return null;
		}

  	    const topic = [];
    		msg.forEach(function(t) {
          	if (typeof t === 'string') {
  	           	topic.push(t);
  	        }
  	    });
      	return topic.join('/');
    	}

	function makePayload(msg) {
		if (!msg || msg.length == 0) {
          	return null;
		}

		if (msg.length == 1) {
          	return msg[0];
  		}

      	const payload = {};
		msg.forEach(function(e) {
             	if (Array.isArray(e)) {
              	const key = e[0];
				const name = e[1];
				if (e.length == 3) {
                  	if (!(key in payload)) {
                      	payload[key] = {};
					}
                  	payload[key][name] = e[2];
				} else {
                  	payload[key] = name;
				}
             	}
		});
		return payload;
	}

	peg$result = peg$startRuleFunction();

	if (peg$result !== peg$FAILED && peg$currPos === input.length) {
		return peg$result;
	} else {
		if (peg$result !== peg$FAILED && peg$currPos < input.length) {
			peg$fail(peg$endExpectation());
		}

		throw peg$buildStructuredError(
			peg$maxFailExpected,
			peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
			peg$maxFailPos < input.length
				? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
				: peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
		);
	}
}

module.exports = {
	SyntaxError: peg$SyntaxError,
	parse: peg$parse
};
